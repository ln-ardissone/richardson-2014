#!/usr/bin/env Rscript

library(optparse)

option_list <- c(make_option('--input', type='character', default='dipp-rf-uniq.RData'),
                 make_option('--rank', type='character', default='Species'),
                 make_option('--width', type='numeric', default=51),
                 make_option('--output', type='character', default='RPlots.pdf'),
                 make_option('--top', type='numeric', default=4),
                 make_option('--test', type='character', default='glm')
                )

source('lib/se.R')
source('lib/ggplot_theme.R')

parser <- OptionParser(option_list = option_list)
options <- parse_args(parser)

library(phyloseq)
library(zoo)
library(plyr)
library(ggplot2)
library(qvalue)
library(doParallel)

registerDoParallel(cores=4)

load(options$input)

glom <- tax_glom(dipp, taxrank = options$rank)

form <- parse(text=paste(options$rank, '%in%', 'names(top_phy)'))
top_phy <- sort(tapply(taxa_sums(glom), tax_table(glom)[, options$rank], sum), decreasing=TRUE)[1:options$top]
glom <- subset_taxa(glom, eval(form))

df <- psmelt(glom)

# do this if you want equal-sized windows
# TODO make this optional.
# --equal_windows or something...
#start <- min(df$age_at_sampling)
#stop <- max(600)
#fake_df <- data.frame(age_at_sampling = start:stop)
#merged <- merge(fake_df, df, all=T)

# calculate rolling median and rolling standard error
# for each OTU at Rank

# sort by age
df <- df[with(df, order(age_at_sampling)),]

# "extra variables"
vars <- c('vaginal_delivery',
          'Gender')

# take only what we need
n <- df[,c(vars, 'seroconverted', 'age_at_sampling', options$rank, 'Abundance', 'dipp_person')]

form <- parse(text=paste('~', options$rank))

smoothed <- ddply(n, eval(form), .parallel=T, function(d) {
  data.frame(rollapply(rownames(d), options$width, function(i) {
    ss <- d[i,] # the slow part! (fixme)
    r <- range(ss$age_at_sampling)
    d <- max(ss$age_at_sampling) - min(ss$age_at_sampling)
    n <- nrow(ss)

    cat('range:', r, 'width:', d, 'count:', n, '\n')

    downsampled <- ddply(ss, ~ dipp_person, function(y) {
      c(Abundance=median(y$Abundance),
        age_at_sampling=median(y$age_at_sampling),
        seroconverted=y[1,]$seroconverted,
        Gender=y[1,]$Gender,
        vaginal_delivery=y[1,]$vaginal_delivery
       )
    })

    if (options$test == 'wilcox') {
      p.value <- wilcox.test(Abundance ~ seroconverted, data=downsampled, exact=FALSE)$p.value
    } else if (options$test == 'glm') {
      m1 <- glm(Abundance ~ Gender + vaginal_delivery, data=downsampled)
      m2 <- glm(seroconverted ~ residuals(m1), data=downsampled)
      p.value <- anova(m2, test='Chisq')[[5]][[2]]
      ll2 <- logLik(m2)
      ll1 <- logLik(m1)
    }

    averaged <- ddply(downsampled, ~ seroconverted, function(y) {
          c(abundance=median(y$Abundance),
            abundance.se=se(y$Abundance),
            age=median(y$age_at_sampling))
    })
    averaged$p.value <- p.value
    averaged$ll1 <- ll1
    averaged$ll2 <- ll2
    return(averaged)
  }))
})

# plot it!

pdf(options$output, 8, 10, colormodel='cmyk')

smoothed$seroconverted <- as.factor(smoothed$seroconverted)
smoothed <- smoothed[complete.cases(smoothed),]

smoothed$q.value <- qvalue(smoothed$p.value)$qvalue

ggplot(smoothed,
       aes_string(x='age',
                  y='abundance',
                  color=options$rank)) +
geom_point() +
facet_grid(seroconverted ~ .)

form <- parse(text=paste('~', options$rank))


ggplot(smoothed,
       aes_string(x='age',
           y='abundance',
           fill='seroconverted')) +
facet_wrap(eval(form), scale='free_y') +
geom_ribbon(aes(ymin = abundance - abundance.se, ymax= abundance + abundance.se), alpha=0.5) +
geom_rug(aes(color=q.value < 0.05), sides='b') +
xlim(min(smoothed$age), 600) +
ggplot.theme

dev.off()
